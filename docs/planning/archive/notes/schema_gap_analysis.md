# Schema Gap Analysis: Reference vs. Fresh Start

**Date:** December 25, 2025
**Goal:** Verify that the new Discrete-Event Simulation (DES) architecture captures 100% of the data richness from the reference `schema.sql` (67 Tables).

## 1. Domain Mapping Overview

| SCOR Domain | Ref Tables | Fresh Start Handling | Coverage Strategy |
| :--- | :--- | :--- | :--- |
| **A. SOURCE** | 8 | **Hybrid:** Static Suppliers + Dynamic POs | `Source_Engine` generates `purchase_orders` based on `inventory` signals. |
| **B. TRANSFORM** | 9 | **Emergent:** MRP-driven | `Transform_Engine` schedules `work_orders` when `net_requirements` > 0. |
| **C. PRODUCT** | 5 | **Static:** World Building | Loaded directly from Reference Config (L0-L4) at $t=0$. |
| **D. ORDER** | 7 | **Emergent:** Agent-driven | `POS_Engine` drives `orders` via `Replenishment_Agent`. |
| **E. FULFILL** | 11 | **Emergent:** Physics-constrained | `Fulfill_Engine` builds `shipments` using Tetris Logic (Weight/Cube). |
| **E2. LOGISTICS** | 7 | **Hybrid:** Static Network + Dynamic Legs | `Link` objects enforce `route_segments` physics; `shipment_legs` recorded dynamically. |
| **E3. ESG** | 5 | **Post-Process / Integrated** | `Emission_Actor` calculates CO2 based on `shipment_legs` distance/mode. |
| **F. PLAN** | 9 | **Derived:** Snapshot | `Plan_Engine` snapshots `inventory` state to create `supply_plans`. |
| **G. RETURN** | 4 | **Probabilistic:** Quirk Layer | `Return_Agent` generates RMAs based on failure rates. |
| **H. ORCHESTRATE** | 6 | **Observer:** Monitor | `Realism_Monitor` records `kpi_actuals` and `risk_events`. |

## 2. Detailed Gap Analysis (By Key Table)

### A. Inventory (`inventory`)
*   **Reference:** A static snapshot or simple daily decay.
*   **Fresh Start:** A **State Tensor** ($I_{t, sku, loc}$).
*   **Verdict:** **Superior.** The new system tracks inventory continuously in memory. We will implement a `Persistence_Manager` to flush this tensor to the `inventory` table format for compatibility.

### B. Shipments (`shipments`, `shipment_lines`)
*   **Reference:** Generated based on statistical demand.
*   **Fresh Start:** Generated by the **Tetris Engine**.
*   **Verdict:** **Parity + Physics.** We retain the schema (Weight, Cases, Pallets) but populate it using real bin-packing logic rather than statistical averages.

### C. Capacity (`capacity_plans`, `production_lines`)
*   **Reference:** Statistical availability.
*   **Fresh Start:** Finite constraints.
*   **Verdict:** **Superior.** `production_lines` are static capacity nodes. `capacity_plans` are dynamic reservations made by the `Scheduler`.

### D. Forecasting (`demand_forecasts`, `forecast_accuracy`)
*   **Reference:** Generated via Zipf/Gamma distributions + Bias.
*   **Fresh Start:** Generated by the `Forecast_Agent`.
*   **Verdict:** **Parity.** We explicitly port the "Optimism Bias" logic to the `Forecast_Agent` to ensure the `forecast_accuracy` table shows the same realistic errors.

### E. Risk & ESG (`risk_events`, `shipment_emissions`)
*   **Reference:** Probabilistic injection.
*   **Fresh Start:** Deterministic & Emergent.
*   **Verdict:** **Parity.** We reuse the `benchmark_manifest.json` to trigger `risk_events`. `shipment_emissions` are calculated exactly as in reference (Distance * Factor).

## 3. Conclusion
**No tables are dropped.** The "Fresh Start" architecture is a **Superset** of the reference.
*   **Static Tables (30%):** Ported 1:1 during "World Building."
*   **Dynamic Tables (70%):** Generated by Physics Engines but mapped 1:1 to the original schema structure for validation.

The "richness" is preserved because the **Output Interface** (the SQL Schema) remains the contract, while the **Input Mechanism** changes from "Scripted Generation" to "Simulation."
